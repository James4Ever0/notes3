---
tags: [interval, math, mathematica, sympy, wolfram]
title: 连续区间 离散区间 从离散数据中获得离散区间 交并补
created: '2022-08-22T14:30:28.000Z'
modified: '2022-08-23T03:51:35.462Z'
---

# 连续区间 离散区间 从离散数据中获得离散区间 交并补

离散区间的获得可以用边界条件判定 即最近n个连续的概率大于多少 容忍值为多少 最近n个小于多少直接作为结束边界的条件 也可以用convolution Gaussian blur

离散区间交并补可以转化为连续区间交并补 更简单省事

如果要做下面的运算 建议用第三方库 比如wolfram swi-prolog的clpr sympy

连续区间交并补 先排序 设置首末端的操作 然后进行相应区间选取 进行下一步操作直到结束 输出总的结果

less exponential solution here?
```bash
# basically the same example.
# assume no overlapping here.
import sympy
def tupleSetToUncertain(mSet):
  for start, end in mSet:
    if mUncertain is None:
      mUncertain = sympy.Interval(start,end)
    else:
      mUncertain += sympy.Interval(start,end)
  typeUncertain = type(mUncertain)
  return mUncertain, typeUncertain

def mergeOverlappedInIntervalTupleList(intervalTupleList):
  mUncertain, _ = tupleSetToUncertain(intervalTupleList)
  mUncertainBoundaryList = list(mUncertain.boundary)
  mergedIntervalTupleList = zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2])
  return mergedIntervalTupleList

mSet = mergeOverlappedInIntervalTupleList([(0,1), (2,3)])
mSet2 = mergeOverlappedInIntervalTupleList([(0.5,1.5),(1.6,2.5)])

mSetCandidates = [mSet, mSet2]
mSetUnified = [x for y in mSetCandidates for x in y]
leftBoundaryList = set([x[0] for x in mSetUnified])
rightBoundaryList = set([x[1] for x in mSetUnified])
# they may freaking overlap.
# if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.

markers = {"enter":{k:[] for k in leftBoundaryList}, "exit":{k:[] for k in rightBoundaryList}}

for index, mSetCandidate in enumerate(mSetCandidates):
  leftBoundaryListOfCandidate = [x[0] for x in mSetCandidate]
  rightBoundaryListOfCandidate = [x[1] for x in mSetCandidate]
  for leftBoundaryOfCandidate in leftBoundaryListOfCandidate:
    markers["enter"][leftBoundaryOfCandidate].append(index) # remap this thing!
  for rightBoundaryOfCandidate in rightBoundaryListOfCandidate:
    markers["exit"][rightBoundaryOfCandidate].append(index) # remap this thing!
  
# now, iterate through the boundaries of mSetUnified.
unifiedBoundaryList = leftBoundaryList.union(rightBoundaryList) # call me a set instead of a list please? now we must sort this thing
unifiedBoundaryList = list(unifiedBoundaryList)
unifiedBoundaryList.sort()

unifiedBoundaryMarks = {}
for index, boundary in enumerate(unifiedBoundaryList):
  previousMark = unifiedBoundaryMarks.get(index-1, [])
  enterList = markers["enter"][boundary]
  exitList = markers["exit"][boundary]
  currentMark = set(previousMark + enterList).difference(set(exitList))
  currentMark = list(currentMark)
  unifiedBoundaryMarks.update({index:currentMark})
  # now, handle the change? or not?
  # let's just deal those empty ones, shall we?
  if previousMark == []: continue # will handle it later, please?
  # elif currentMark == []:
    # the end of previous mark! this interval belongs to previousMark
  else:
    # also the end of previous mark! belongs to previousMark.

```

sympy seems to provide support for discrete and continuous interval? will that save any damn time anyway? i'm afraid no? maybe there's a way!

first combine all intervals in same set:
```bash
import sympy

def tupleSetToUncertain(mSet):
  for start, end in mSet:
    if mUncertain is None:
      mUncertain = sympy.Interval(start,end)
    else:
      mUncertain += sympy.Interval(start,end)
  typeUncertain = type(mUncertain)
  return mUncertain, typeUncertain

mSet = [(0,1), (2,3)]
mUncertain, typeUncertain = tupleSetToUncertain(mSet)
unrolledMSet = list(mUncertain.boundary)
# can be either sympy.sets.sets.Interval of sympy.sets.sets.Union

mSet2 = [(0.5,1.5),(1.6,2.5)]
mUncertain2, typeUncertain2 = tupleSetToUncertain(mSet2)
unrolledMSet2 = list(mUncertain2.boundary)
```

next let's get all sub-intervals! waiting for verification though
```bash
# hypothetical mSet2 and mUncertain2! please complete the hypothetical shit and make it runnable!

def checkCommon(subInterval, masterInterval):
  return subInterval == sympy.Intersection(subInterval, masterInterval)

mUncertains = [mUncertain, mUncertain2]
subIntervals = list(set(unrolledMSet2 + unrolledMSet))
subIntervals.sort()

subIntervals = zip(subIntervals[:-1], subIntervals[1:])
# for subIntervals, it's still not real interval but tuple at above line.

reversedCats = {}

for subIntervalIndex, (start, end) in enumerate(subIntervals):
  subIntervalCandidate = sympy.Interval(start, end)
  reverseIndex = [] # there must be at least one such index.
  for index, uncertainCandidate in enumerate(mUncertains):
    if checkCommon(subIntervalCandidate, uncertainCandidate):
      reverseIndex.append(index) # this is the index of the in-common set of the original set list
  reversedCats.update({subIntervalIndex:reverseIndexTuple}) # need to sort and index? or not to sort because this is already done?

normalCats = {}
for k,v in reversedCats.items():
  normalCats.update({v:normalCats.get(v, [])+[k]})
# we only get interval, not the actural union period!
# how to get interval elements out of union structure for hell sake?

finalCats = {}
for k,v in normalCats.keys():
  # now k is the original set index list, representing belonging of the below union.
  mFinalUnionCandidate = [tuple(subIntervals[index]) for index in v]
  mFinalUnionCandidate = tupleSetToUncertain(mFinalUnionCandidate) 
  mFinalUnionCandidateBoundaryList = list(mFinalUnionCandidate.boundary)
  left_bounds, right_bounds = mFinalUnionCandidateBoundaryList[0::2],mFinalUnionCandidateBoundaryList[1::2] # check it dammit! not sure how to step the list properly?
  mFinalIntervalListCandidate = zip(left_bounds, right_bounds)
  finalCats.update({k:mFinalIntervalListCandidate})
# this whole calculation could just be exponential. goddamn it?
print("_____FINAL CATS_____")
print(finalCats)
``````
